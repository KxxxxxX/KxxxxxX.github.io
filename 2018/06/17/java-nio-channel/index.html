<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="java,nio,通道channel," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="1、通道基础通道（Channel）是 java.nio 的第二个主要创新。它们既不是一个扩展也不是一项增强，而是全新、极好的 Java I/O 示例，提供与 I/O 服务的直接连接。 Channel 用于在字节缓冲区和位于通道另一侧的实体（通常是一个文件或套接字）之间有效地传输数据  多数情况下，通道与操作系统的文件描述符（File Descriptor）和文件句柄（File Handle）有着一">
<meta name="keywords" content="java,nio,通道channel">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaNIO学习笔记--Channel（通道）">
<meta property="og:url" content="http://yoursite.com/2018/06/17/java-nio-channel/index.html">
<meta property="og:site_name" content="那美克星">
<meta property="og:description" content="1、通道基础通道（Channel）是 java.nio 的第二个主要创新。它们既不是一个扩展也不是一项增强，而是全新、极好的 Java I/O 示例，提供与 I/O 服务的直接连接。 Channel 用于在字节缓冲区和位于通道另一侧的实体（通常是一个文件或套接字）之间有效地传输数据  多数情况下，通道与操作系统的文件描述符（File Descriptor）和文件句柄（File Handle）有着一">
<meta property="og:image" content="http://yoursite.com/2018/06/17/java-nio-channel/java-nio-channel/1532328228905.png">
<meta property="og:image" content="http://yoursite.com/2018/06/17/java-nio-channel/java-nio-channel/1532332954565.png">
<meta property="og:image" content="http://yoursite.com/2018/06/17/java-nio-channel/java-nio-channel/1532338664551.png">
<meta property="og:image" content="http://yoursite.com/2018/06/17/java-nio-channel/java-nio-channel/1532358532450.png">
<meta property="og:image" content="http://yoursite.com/2018/06/17/java-nio-channel/java-nio-channel/1532359375876.png">
<meta property="og:updated_time" content="2018-07-24T01:54:29.541Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaNIO学习笔记--Channel（通道）">
<meta name="twitter:description" content="1、通道基础通道（Channel）是 java.nio 的第二个主要创新。它们既不是一个扩展也不是一项增强，而是全新、极好的 Java I/O 示例，提供与 I/O 服务的直接连接。 Channel 用于在字节缓冲区和位于通道另一侧的实体（通常是一个文件或套接字）之间有效地传输数据  多数情况下，通道与操作系统的文件描述符（File Descriptor）和文件句柄（File Handle）有着一">
<meta name="twitter:image" content="http://yoursite.com/2018/06/17/java-nio-channel/java-nio-channel/1532328228905.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/06/17/java-nio-channel/"/>





  <title>JavaNIO学习笔记--Channel（通道） | 那美克星</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">那美克星</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录学习</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/17/java-nio-channel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="kx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="那美克星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JavaNIO学习笔记--Channel（通道）</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-17T12:05:12+08:00">
                2018-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="1、通道基础"><a href="#1、通道基础" class="headerlink" title="1、通道基础"></a>1、通道基础</h1><p>通道（Channel）是 java.nio 的第二个主要创新。它们既不是一个扩展也不是一项增强，而是全新、极好的 Java I/O 示例，提供与 I/O 服务的直接连接。 Channel 用于在字节缓冲区和位于通道另一侧的实体（通常是一个文件或套接字）之间有效地传输数据 </p>
<p>多数情况下，通道与操作系统的文件描述符（File Descriptor）和文件句柄（File Handle）有着一对一的关系。虽然通道比文件描述符更广义，但您将经常使用到的多数通道都是连接到开放的文件描述符的。 Channel 类提供维持平台独立性所需的抽象过程，不过仍然会模拟现代操作系统本身的 I/O 性能 </p>
<!--程序清单：Channel接口-->
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.nio.channels;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Channel</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">( )</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">( )</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与缓冲区不同，通道 API 主要由接口指定。不同的操作系统上通道实现（Channel Implementation）会有根本性的差异，所以通道 API 仅仅描述了可以做什么。通道实现经常使用操作系统的本地代码。通道接口允许您以一种受控且可移植的方式来访问底层的 I/O服务 </p>
<h3 id="1-1、打开通道"><a href="#1-1、打开通道" class="headerlink" title="1.1、打开通道"></a>1.1、打开通道</h3><p>I/O 可以分为广义的两大类别：File I/O 和 Stream I/O。相应地有两种类型的通道，它们是文件（file）通道和套接字（socket）通道。 参考一下图，会发现有一个 <code>FileChannel</code> 类和三个 socket 通道类： <code>SocketChannel</code>、 <code>ServerSocketChannel</code> 和 <code>DatagramChannel</code>。 </p>
<p>通道可以以多种方式创建。 <code>Socket</code> 通道有可以直接创建新 socket 通道的工厂方法。但是一个<code>FileChannel</code> 对象却只能通过在一个打开的 <code>RandomAccessFile</code>、 <code>FileInputStream</code> 或 <code>FileOutputStream</code>对象上调用 <code>getChannel( )</code>方法来获取。您不能直接创建一个 <code>FileChannel</code> 对象 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel sc = SocketChannel.open( );</span><br><span class="line">sc.connect (<span class="keyword">new</span> InetSocketAddress (<span class="string">"somehost"</span>, someport));</span><br><span class="line">ServerSocketChannel ssc = ServerSocketChannel.open( );</span><br><span class="line">ssc.socket( ).bind (<span class="keyword">new</span> InetSocketAddress (somelocalport));</span><br><span class="line">DatagramChannel dc = DatagramChannel.open( );</span><br><span class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile (<span class="string">"somefile"</span>, <span class="string">"r"</span>);</span><br><span class="line">FileChannel fc = raf.getChannel( );</span><br></pre></td></tr></table></figure>
<h3 id="1-2、使用通道"><a href="#1-2、使用通道" class="headerlink" title="1.2、使用通道"></a>1.2、使用通道</h3><p><img src="java-nio-channel\1532328228905.png" alt="53232822890"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadableByteChannel</span> <span class="keyword">extends</span> <span class="title">Channel</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span> <span class="params">(ByteBuffer dst)</span> <span class="keyword">throws</span> IOException</span>;<span class="number">57</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WritableByteChannel</span> <span class="keyword">extends</span> <span class="title">Channel</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">write</span> <span class="params">(ByteBuffer src)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ByteChannel</span> <span class="keyword">extends</span> <span class="title">ReadableByteChannel</span>, <span class="title">WritableByteChannel</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<p>​    通道可以是单向（unidirectional）或者双向的（bidirectional）。一个 channel 类可能实现定义<code>read( )</code>方法的 <code>ReadableByteChanne</code>l 接口，而另一个 <code>channel</code> 类也许实现 <code>WritableByteChannel</code> 接口以提供 <code>write( )</code>方法。实现这两种接口其中之一的类都是单向的，只能在一个方向上传输数据。如果一个类同时实现这两个接口，那么它是双向的，可以双向传输数据。 <code>ByteChannel</code> 接口本身并不定义新的 API 方法，它是一种用来聚集它自己以一个新名称继承的多个接口的便捷接口。 </p>
<p>​    通道会连接一个特定 I/O 服务且通道实例（channel instance）的性能受它所连接的 I/O 服务的特征限制，记住这很重要。一个连接到只读文件的 Channel 实例不能进行写操作，即使该实例所属的类可能有 write( )方法。基于此，程序员需要知道通道是如何打开的，避免试图尝试一个底层 I/O服务不允许的操作。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A ByteBuffer named buffer contains data to be written</span></span><br><span class="line">FileInputStream input = <span class="keyword">new</span> FileInputStream (fileName);</span><br><span class="line">FileChannel channel = input.getChannel( );</span><br><span class="line"><span class="comment">// This will compile but will throw an IOException</span></span><br><span class="line"><span class="comment">// because the underlying file is read-only</span></span><br><span class="line">channel.write (buffer);</span><br></pre></td></tr></table></figure>
<p>​    ByteChannel 的 read( ) 和 write( )方法使用 ByteBuffer 对象作为参数。两种方法均返回已传输的字节数，可能比缓冲区的字节数少甚至可能为零。缓冲区的位置也会发生与已传输字节相同数量的前移。如果只进行了部分传输，缓冲区可以被重新提交给通道并从上次中断的地方继续传输。该过程重复进行直到缓冲区的 hasRemaining( )方法返回 false 值。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ReadableByteChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.WritableByteChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Channels;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Test copying between channels.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Ron Hitchens (ron@ronsoft.com)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelCopy</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * This code copies data from stdin to stdout. Like the 'cat'</span></span><br><span class="line"><span class="comment">    * command, but without any useful options.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String [] argv)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ReadableByteChannel source = Channels.newChannel (System.in);</span><br><span class="line">        WritableByteChannel dest = Channels.newChannel (System.out);</span><br><span class="line">        channelCopy1 (source, dest);</span><br><span class="line">        <span class="comment">// alternatively, call channelCopy2 (source, dest);</span></span><br><span class="line">        source.close( );</span><br><span class="line">        dest.close( );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Channel copy method 1. This method copies data from the src</span></span><br><span class="line"><span class="comment">    * channel and writes it to the dest channel until EOF on src.</span></span><br><span class="line"><span class="comment">    * This implementation makes use of compact( ) on the temp buffer</span></span><br><span class="line"><span class="comment">    * to pack down the data if the buffer wasn't fully drained. This</span></span><br><span class="line"><span class="comment">    * may result in data copying, but minimizes system calls. It also</span></span><br><span class="line"><span class="comment">    * requires a cleanup loop to make sure all the data gets sent.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">channelCopy1</span> <span class="params">(ReadableByteChannel src,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      WritableByteChannel dest)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocateDirect (<span class="number">16</span> * <span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">while</span> (src.read (buffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// Prepare the buffer to be drained</span></span><br><span class="line">            buffer.flip( );</span><br><span class="line">            <span class="comment">// Write to the channel; may block</span></span><br><span class="line">            dest.write (buffer);</span><br><span class="line">            <span class="comment">// If partial transfer, shift remainder down</span></span><br><span class="line">            <span class="comment">// If buffer is empty, same as doing clear( )60</span></span><br><span class="line">            buffer.compact( );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// EOF will leave buffer in fill state</span></span><br><span class="line">        buffer.flip( );</span><br><span class="line">        <span class="comment">// Make sure that the buffer is fully drained</span></span><br><span class="line">        <span class="keyword">while</span> (buffer.hasRemaining( )) &#123;</span><br><span class="line">            dest.write (buffer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**	</span></span><br><span class="line"><span class="comment">    * Channel copy method 2. This method performs the same copy, but</span></span><br><span class="line"><span class="comment">    * assures the temp buffer is empty before reading more data. This</span></span><br><span class="line"><span class="comment">    * never requires data copying but may result in more systems calls.</span></span><br><span class="line"><span class="comment">    * No post-loop cleanup is needed because the buffer will be empty</span></span><br><span class="line"><span class="comment">    * when the loop is exited.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">channelCopy2</span> <span class="params">(ReadableByteChannel src,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      WritableByteChannel dest)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocateDirect (<span class="number">16</span> * <span class="number">1024</span>);</span><br><span class="line">        	<span class="keyword">while</span> (src.read (buffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">        		<span class="comment">// Prepare the buffer to be drained</span></span><br><span class="line">        		buffer.flip( );</span><br><span class="line">        		<span class="comment">// Make sure that the buffer was fully drained</span></span><br><span class="line">        		<span class="keyword">while</span> (buffer.hasRemaining( )) &#123;</span><br><span class="line">        		dest.write (buffer);</span><br><span class="line">        		&#125;</span><br><span class="line">				<span class="comment">// Make the buffer empty, ready for filling</span></span><br><span class="line">				buffer.clear( );</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通道可以以阻塞（blocking）或非阻塞（nonblocking）模式运行。非阻塞模式的通道永远不会让调用的线程休眠。请求的操作要么立即完成，要么返回一个结果表明未进行任何操作。只有面向流的（stream-oriented）的通道，如 sockets 和 pipes 才能使用非阻塞模式。 </p>
<h3 id="1-3、关闭通道"><a href="#1-3、关闭通道" class="headerlink" title="1.3、关闭通道"></a>1.3、关闭通道</h3><p>与缓冲区不同，通道不能被重复使用。一个打开的通道即代表与一个特定 I/O 服务的特定连接并封装该连接的状态。当通道关闭时，那个连接会丢失，然后通道将不再连接任何东西。 </p>
<p>调用通道的<code>close( )</code>方法时，可能会导致在通道关闭底层I/O服务的过程中线程暂时阻塞 ，哪怕该通道处于非阻塞模式。通道关闭时的阻塞行为（如果有的话）是高度取决于操作系统或者文件系统的。在一个通道上多次调用<code>close( )</code>方法是没有坏处的，但是如果第一个线程在<code>close( )</code>方法中阻塞，那么在它完成关闭通道之前，任何其他调用close( )方法都会阻塞。后续在该已关闭的通道上调用<code>close( )</code>不会产生任何操作，只会立即返回。 </p>
<p>可以通过 <code>isOpen( )</code>方法来测试通道的开放状态。如果返回 true 值，那么该通道可以使用。如果返回 false 值，那么该通道已关闭，不能再被使用。尝试进行任何需要通道处于开放状态作为前提的操作，如读、写等都会导致 <code>ClosedChannelException</code> 异常。 </p>
<p>通道引入了一些与关闭和中断有关的新行为。如果一个通道实现 <code>InterruptibleChannel</code> 接口，它的行为以下述语义为准：</p>
<p>如果一个线程在一个通道上被阻塞并且同时被中断（由调用该被阻塞线程的 <code>interrupt( )</code>方法的另一个线程中断），那么该通道将被关闭，该被阻塞线程也会产生一个<code>ClosedByInterruptException</code> 异常。此外，假如一个线程的 interrupt status 被设置并且该线程试图访问一个通道，那么这个通道将立即被关闭，同时将抛出相同的 <code>ClosedByInterruptException</code> 异常。  </p>
<hr>
<h1 id="2、Scatter-Gather"><a href="#2、Scatter-Gather" class="headerlink" title="2、Scatter/Gather"></a>2、Scatter/Gather</h1><p>通道提供了一种被称为 <strong>Scatter/Gather</strong> 的重要新功能（有时也被称为<strong>矢量 I/O</strong>）。</p>
<p> <strong>Scatter/Gather</strong>是一个简单却强大的概念，它是指在多个缓冲区上实现一个简单的 I/O 操作。对于一个 write 操作而言，数据是从几个缓冲区按顺序抽取（称为 gather）并沿着通道发送的。缓冲区本身并不需要具备这种 gather 的能力（通常它们也没有此能力）。该 gather 过程的效果就好比全部缓冲区的内容被连结起来，并在发送数据前存放到一个大的缓冲区中。对于 read 操作而言，从通道读取的数据会按顺序被散布（称为 scatter）到多个缓冲区，将每个缓冲区填满直至通道中的数据或者缓冲区的最大空间被消耗完。<br>    大多数现代操作系统都支持本地矢量 I/O（native vectored I/O）。当您在一个通道上请求一个<br>Scatter/Gather 操作时，该请求会被翻译为适当的本地调用来直接填充或抽取缓冲区。这是一个很大<br>的进步，因为减少或避免了缓冲区拷贝和系统调用。 Scatter/Gather 应该使用直接的 <code>ByteBuffers</code> 以从<br>本地 I/O 获取最大性能优势。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ScatteringByteChannel</span> <span class="keyword">extends</span> <span class="title">ReadableByteChannel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">read</span> <span class="params">(ByteBuffer [] dsts)</span> </span></span><br><span class="line"><span class="function">    	<span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">read</span> <span class="params">(ByteBuffer [] dsts, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span></span><br><span class="line"><span class="function">    	<span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GatheringByteChannel</span> <span class="keyword">extends</span> <span class="title">WritableByteChannel</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">write</span><span class="params">(ByteBuffer[] srcs)</span> </span></span><br><span class="line"><span class="function">    	<span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">write</span><span class="params">(ByteBuffer[] srcs, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span></span><br><span class="line"><span class="function">    	<span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>带 offset 和 length 参数版本的 <code>read( )</code> 和 <code>write( )</code>方法使得我们可以使用缓冲区阵列的子集缓冲区。这里的 offset 值指哪个缓冲区将开始被使用，而不是指数据的 <code>offset</code>。这里的 <code>length</code> 参数指示要使用的缓冲区数量。举个例子，假设我们有一个五元素的 <code>fiveBuffers</code> 阵列，它已经被初始化并引用了五个缓冲区，下面的代码将会写第二个、第三个和第四个缓冲区的内容：<br><code>int bytesRead = channel.write (fiveBuffers, 1, 3);</code> </p>
<p>使用得当的话， Scatter/Gather 会是一个极其强大的工具。它允许委托操作系统来完成辛苦活：将读取到的数据分开存放到多个存储桶（bucket）或者将不同的数据区块合并成一个整体。这是一个巨大的成就，因为操作系统已经被高度优化来完成此类工作了。它节省了来回移动数据的工作，也就避免了缓冲区拷贝和减少了需要编写、调试的代码数量。下面代码很好地诠释了这一点： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.GatheringByteChannel;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Demonstrate gathering write using many buffers.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Ron Hitchens (ron@ronsoft.com)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Marketing</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEMOGRAPHIC = <span class="string">"blahblah.txt"</span>;</span><br><span class="line">    <span class="comment">// "Leverage frictionless methodologies"</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String [] argv)</span> </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> reps = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (argv.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        	reps = Integer.parseInt (argv [<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream (DEMOGRAPHIC);</span><br><span class="line">        GatheringByteChannel gatherChannel = fos.getChannel( );</span><br><span class="line">        <span class="comment">// Generate some brilliant marcom, er, repurposed content</span></span><br><span class="line">        ByteBuffer [] bs = utterBS (reps);</span><br><span class="line">        <span class="comment">// Deliver the message to the waiting market</span></span><br><span class="line">        <span class="keyword">while</span> (gatherChannel.write (bs) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Empty body</span></span><br><span class="line">        <span class="comment">// Loop until write( ) returns zero</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println (<span class="string">"Mindshare paradigms synergized to "</span></span><br><span class="line">        + DEMOGRAPHIC);<span class="number">67</span></span><br><span class="line">        fos.close( );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ------------------------------------------------</span></span><br><span class="line">    <span class="comment">// These are just representative; add your own</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String [] col1 = &#123;</span><br><span class="line">        <span class="string">"Aggregate"</span>, <span class="string">"Enable"</span>, <span class="string">"Leverage"</span>,</span><br><span class="line">        <span class="string">"Facilitate"</span>, <span class="string">"Synergize"</span>, <span class="string">"Repurpose"</span>,</span><br><span class="line">        <span class="string">"Strategize"</span>, <span class="string">"Reinvent"</span>, <span class="string">"Harness"</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String [] col2 = &#123;</span><br><span class="line">        <span class="string">"cross-platform"</span>, <span class="string">"best-of-breed"</span>, <span class="string">"frictionless"</span>,</span><br><span class="line">        <span class="string">"ubiquitous"</span>, <span class="string">"extensible"</span>, <span class="string">"compelling"</span>,</span><br><span class="line">        <span class="string">"mission-critical"</span>, <span class="string">"collaborative"</span>, <span class="string">"integrated"</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String [] col3 = &#123;</span><br><span class="line">        <span class="string">"methodologies"</span>, <span class="string">"infomediaries"</span>, <span class="string">"platforms"</span>,</span><br><span class="line">        <span class="string">"schemas"</span>, <span class="string">"mindshare"</span>, <span class="string">"paradigms"</span>,</span><br><span class="line">        <span class="string">"functionalities"</span>, <span class="string">"web services"</span>, <span class="string">"infrastructures"</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String newline = System.getProperty (<span class="string">"line.separator"</span>);</span><br><span class="line">    <span class="comment">// The Marcom-atic 9000</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ByteBuffer [] utterBS (<span class="keyword">int</span> howMany)</span><br><span class="line">        <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        List list = <span class="keyword">new</span> LinkedList( );</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; howMany; i++) &#123;</span><br><span class="line">            list.add (pickRandom (col1, <span class="string">" "</span>));</span><br><span class="line">            list.add (pickRandom (col2, <span class="string">" "</span>));</span><br><span class="line">            list.add (pickRandom (col3, newline));</span><br><span class="line">    	&#125;</span><br><span class="line">        ByteBuffer [] bufs = <span class="keyword">new</span> ByteBuffer [list.size( )];</span><br><span class="line">        list.toArray (bufs);</span><br><span class="line">        <span class="keyword">return</span> (bufs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The communications director</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random( );</span><br><span class="line">    <span class="comment">// Pick one, make a buffer to hold it and the suffix, load it with</span></span><br><span class="line">    <span class="comment">// the byte equivalent of the strings (will not work properly for68</span></span><br><span class="line">    <span class="comment">// non-Latin characters), then flip the loaded buffer so it's ready</span></span><br><span class="line">    <span class="comment">// to be drained</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ByteBuffer <span class="title">pickRandom</span> <span class="params">(String [] strings, String suffix)</span></span></span><br><span class="line"><span class="function">    	<span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String string = strings [rand.nextInt (strings.length)];</span><br><span class="line">        <span class="keyword">int</span> total = string.length() + suffix.length( );</span><br><span class="line">        ByteBuffer buf = ByteBuffer.allocate (total);</span><br><span class="line">        buf.put (string.getBytes (<span class="string">"US-ASCII"</span>));</span><br><span class="line">        buf.put (suffix.getBytes (<span class="string">"US-ASCII"</span>));</span><br><span class="line">        buf.flip( );</span><br><span class="line">        <span class="keyword">return</span> (buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是实现 Marketing 类的输出。虽然这种输出没什么意义，但是 gather 写操作却能让我们非常高效地把它生成出来。 </p>
<blockquote>
<p>Aggregate compelling methodologies<br>Harness collaborative platforms<br>Aggregate integrated schemas<br>Aggregate frictionless platforms<br>Enable integrated platforms<br>Leverage cross-platform functionalities<br>Harness extensible paradigms<br>Synergize compelling infomediaries<br>Repurpose cross-platform mindshare<br>Facilitate cross-platform infomediaries </p>
</blockquote>
<hr>
<h1 id="3、文件通道"><a href="#3、文件通道" class="headerlink" title="3、文件通道"></a>3、文件通道</h1><p>从图可以发现，<code>FileChannel</code> 类可以实现常用的 <code>read</code>， <code>write</code> 以及 <code>scatter/gather</code> 操作，同时它也提供了很多专用于文件的新方法。这些方法中的许多都是我们所熟悉的文件操作 </p>
<p><img src="java-nio-channel\1532332954565.png" alt="53233295456"></p>
<p><code>FileChannel</code>对象不能直接创建。一个<code>FileChannel</code>实例只能通过在一个打开的file对象（<code>RandomAccessFile</code>、 <code>FileInputStream</code>或 <code>FileOutputStream</code>）上调用<code>getChannel( )</code>方法获取 。调用<code>getChannel( )</code>方法会返回一个连接到相同文件的<code>FileChannel</code>对象且该<code>FileChannel</code>对象<br>具有与<code>file</code>对象相同的访问权限。</p>
<p><code>FileChannel</code> 对象是线程安全<code>（thread-safe）</code>的。多个进程可以在同一个实例上并发调用方法而不会引起任何问题，不过并非所有的操作都是多线程的<code>（multithreaded）</code>。影响通道位置或者影响文件大小的操作都是单线程的<code>（single-threaded）</code>。如果有一个线程已经在执行会影响通道位置或文件大小的操作，那么其他尝试进行此类操作之一的线程必须等待。并发行为也会受到底层的操作系统或文件系统影响。 </p>
<hr>
<h1 id="4、Socket通道"><a href="#4、Socket通道" class="headerlink" title="4、Socket通道"></a>4、Socket通道</h1><p>​    新的 socket 通道类可以运行<strong>非阻塞模式</strong>并且是<strong>可选择的</strong>。这两个性能可以激活大程序（如网络服务器和中间件组件）巨大的<strong>可伸缩性和灵活性</strong>。 本节中我们会看到，再也没有为每个 socket 连接使用一个线程的必要了，也避免了管理大量线程所需的上下文交换总开销。借助新的 NIO 类，一个或几个线程就可以管理成百上千的活动 socket 连接了并且只有很少甚至可能没有性能损失。 </p>
<p>​    从图可知，全部 socket 通道类（<code>DatagramChannel</code>、 <code>SocketChannel</code> 和<code>ServerSocketChannel</code>）都是由位于 <code>java.nio.channels.spi</code> 包中的 <code>AbstractSelectableChannel</code> 引申而来。这意味着我们可以用一个 Selector 对象来执行 socket 通道的有条件的选择（readiness selection）。选择和多路复用 I/O 会在第四章中讨论。 </p>
<p><img src="java-nio-channel\1532338664551.png" alt="53233866455"></p>
<p>请注意 <code>DatagramChannel</code> 和 <code>SocketChannel</code> 实现定义读和写功能的接口而 <code>ServerSocketChannel</code><br>不实现。 <code>ServerSocketChannel</code> 负责监听传入的连接和创建新的 <code>SocketChannel</code> 对象，它本身从不传输数据。 </p>
<p>全部 socket 通道类（<code>DatagramChannel</code>、 <code>SocketChannel</code> 和 <code>ServerSocketChannel</code>）在被实例化时<br>都会创建一个对等 <code>socket</code> 对象。这些是我们所熟悉的来自 <code>java.net</code> 的类（<code>Socket</code>、 <code>ServerSocket</code><br>和 <code>DatagramSocket</code>），它们已经被更新以识别通道。对等 socket 可以通过调用 <code>socket( )</code>方法从一个<br>通道上获取。此外，这三个 java.net 类现在都有 <code>getChannel( )</code>方法。 </p>
<p>虽然每个 socket 通道（在 <code>java.nio.channels</code> 包中）都有一个关联的 j<code>ava.net socket</code> 对象，却并非所有的 <code>socket</code> 都有一个关联的通道。如果用传统方式（直接实例化）创建了一个<code>Socket</code> 对象，它就不会有关联的 <code>SocketChannel</code> 并且它的 <code>getChannel( )</code>方法将总是返回 null。 </p>
<h3 id="4-1、非阻塞模式"><a href="#4-1、非阻塞模式" class="headerlink" title="4.1、非阻塞模式"></a>4.1、非阻塞模式</h3><p>要把一个 <code>socket</code> 通道置于非阻塞模式，我们要依靠所有 <code>socket</code> 通道类的公有超级类：<code>SelectableChannel</code>。下面的方法就是关于通道的阻塞模式的： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectableChannel</span></span></span><br><span class="line"><span class="class">	<span class="keyword">extends</span> <span class="title">AbstractChannel</span></span></span><br><span class="line"><span class="class">	<span class="keyword">implements</span> <span class="title">Channel</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// This is a partial API listing</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 传递递参数值为 true 则设为阻塞模式，参数值为 false 值设为非阻塞模式。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">configureBlocking</span> <span class="params">(<span class="keyword">boolean</span> block)</span></span></span><br><span class="line"><span class="function">   		<span class="keyword">throws</span> IOException</span>;</span><br><span class="line">   		</span><br><span class="line">   	<span class="comment">// 判断某个 socket 通道当前处于哪种模式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isBlocking</span><span class="params">( )</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 偶尔地，我们也会需要防止 socket 通道的阻塞模式被更改。 API 中有一个 blockingLock( )	</span></span><br><span class="line">    <span class="comment">// 方法，该方法会返回一个非透明的对象引用。返回的对象是通道实现修改阻塞模式时内部使用的。</span></span><br><span class="line">    <span class="comment">// 只有拥有此对象的锁的线程才能更改通道的阻塞模式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Object <span class="title">blockingLock</span><span class="params">( )</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​                            <!-- DEMO --></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Socket socket = <span class="keyword">null</span>;</span><br><span class="line">Object lockObj = serverChannel.blockingLock( );</span><br><span class="line"><span class="comment">// have a handle to the lock object, but haven't locked it yet</span></span><br><span class="line"><span class="comment">// may block here until lock is acquired</span></span><br><span class="line">synchronize (lockObj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// This thread now owns the lock; mode can't be changed</span></span><br><span class="line">    <span class="keyword">boolean</span> prevState = serverChannel.isBlocking( );<span class="number">100</span></span><br><span class="line">    serverChannel.configureBlocking (<span class="keyword">false</span>);</span><br><span class="line">    socket = serverChannel.accept( );</span><br><span class="line">    serverChannel.configureBlocking (prevState);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// lock is now released, mode is allowed to change</span></span><br><span class="line"><span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">	doSomethingWithTheSocket (socket);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2、ServerSocketChannel"><a href="#4-2、ServerSocketChannel" class="headerlink" title="4.2、ServerSocketChannel"></a>4.2、ServerSocketChannel</h3><p><code>ServerSocketChannel</code> 是一个基于通道的 socket 监听器。它同我们所熟悉的 <code>java.net.ServerSocket</code><br>执行相同的基本任务，不过它增加了通道语义，因此能够在非阻塞模式下运行。 </p>
<!--ServerSocketChannel API -->
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerSocketChannel</span></span></span><br><span class="line"><span class="class">	<span class="keyword">extends</span> <span class="title">AbstractSelectableChannel</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ServerSocketChannel <span class="title">open</span><span class="params">( )</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">abstract</span> ServerSocket <span class="title">socket</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ServerSocket <span class="title">accept</span><span class="params">( )</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="comment">// 这个方法与选择器一起使用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">validOps</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>用静态的 <code>open( )</code>工厂方法创建一个新的 <code>ServerSocketChannel</code> 对象，将会返回同一个未绑定的<code>java.net.ServerSocket</code> 关联的通道。对应的 <code>ServerSocket</code> 可以通过在返回的 <code>ServerSocketChannel</code> 上调用 <code>socket( )</code>方法来获取。</p>
<p> 由于 <code>ServerSocketChannel</code> 没有 <code>bind( )</code>方法，因此有必要取出对应的 <code>socket</code> 并使用它来绑定到一<br>个端口以开始监听连接。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel ssc = ServerSocketChannel.open( );</span><br><span class="line">ServerSocket serverSocket = ssc.socket( );</span><br><span class="line"><span class="comment">// Listen on port 1234</span></span><br><span class="line">serverSocket.bind (<span class="keyword">new</span> InetSocketAddress (<span class="number">1234</span>));</span><br></pre></td></tr></table></figure>
<p>与对应的 <code>java.net.ServerSocket</code> 一样， <code>ServerSocketChannel</code> 也有 <code>accept( )</code>方法。一旦创建<br>了一个 <code>ServerSocketChannel</code> 并用对应的 <code>socket</code> 绑定了它，就可以在其中一个上调用 <code>accept( )</code>。</p>
<ul>
<li>如果选择在 <code>ServerSocket</code> 上调用 <code>accept( )</code>方法，那么它会同任何其他的 <code>ServerSocket</code> 表现一样的行为：总是阻塞并返回一个 <code>java.net.Socket</code> 对象。</li>
<li>如果选择在 <code>ServerSocketChannel</code> 上调用 <code>accept( )</code>方法则会返回 <code>SocketChannel</code> 类型的对象，返回的对象能够在非阻塞模式下运行。</li>
</ul>
<p>假设系统已经有一个安全管理器（security manager），两种形式的方法调用都执行相同的安全检查。 </p>
<p>如果以<strong>非阻塞模式</strong>被调用，当没有传入连接在等待时， <code>ServerSocketChannel.accept( )</code>会立即返回 <code>null</code>。正是这种检查连接而不阻塞的能力实现了可伸缩性并降低了复杂性。可选择性也因此得到实现。 </p>
<!--使用 ServerSocketChannel 的非阻塞 accept( )方法  -->
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Test nonblocking accept( ) using ServerSocketChannel.</span></span><br><span class="line"><span class="comment">* Start this program, then "telnet localhost 1234" to</span></span><br><span class="line"><span class="comment">* connect to it.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Ron Hitchens (ron@ronsoft.com)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelAccept</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String GREETING = <span class="string">"Hello I must be going.\r\n"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String [] argv)</span></span></span><br><span class="line"><span class="function">    	<span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">1234</span>; <span class="comment">// default</span></span><br><span class="line">        <span class="keyword">if</span> (argv.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        	port = Integer.parseInt (argv [<span class="number">0</span>]);</span><br><span class="line">    	&#125;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.wrap (GREETING.getBytes( ));</span><br><span class="line">        ServerSocketChannel ssc = ServerSocketChannel.open( );</span><br><span class="line">        ssc.socket( ).bind (<span class="keyword">new</span> InetSocketAddress (port));</span><br><span class="line">        ssc.configureBlocking (<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println (<span class="string">"Waiting for connections"</span>);</span><br><span class="line">            SocketChannel sc = ssc.accept( );</span><br><span class="line">            <span class="keyword">if</span> (sc == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// no connections, snooze a while</span></span><br><span class="line">                Thread.sleep (<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println (<span class="string">"Incoming connection from: "</span></span><br><span class="line">                + sc.socket().getRemoteSocketAddress( ));</span><br><span class="line">                buffer.rewind( );</span><br><span class="line">                sc.write (buffer);</span><br><span class="line">                sc.close( );</span><br><span class="line">            &#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3、SocketChannel"><a href="#4-3、SocketChannel" class="headerlink" title="4.3、SocketChannel"></a>4.3、SocketChannel</h3><!-- SocketChannel -->
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketChannel</span></span></span><br><span class="line"><span class="class">	<span class="keyword">extends</span> <span class="title">AbstractSelectableChannel</span></span></span><br><span class="line"><span class="class">	<span class="keyword">implements</span> <span class="title">ByteChannel</span>, <span class="title">ScatteringByteChannel</span>, <span class="title">GatheringByteChannel</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// This is a partial API listing</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  open( )方法可以创建一个新的 SocketChannel 对象</span></span><br><span class="line">    <span class="comment">// 新创建的 SocketChannel 虽已打开却是未连接的。在一个未连接的 SocketChannel 对象</span></span><br><span class="line">	<span class="comment">//上尝试一个 I/O 操作会导致 NotYetConnectedException 异常。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SocketChannel <span class="title">open</span><span class="params">( )</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="comment">// 带 InetSocketAddress 参数形式的 open( )是在返回之前进行连接的便捷方法</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">static</span> SocketChannel <span class="title">open</span> <span class="params">(InetSocketAddress remote)</span></span></span><br><span class="line"><span class="function">    	<span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    	</span></span><br><span class="line"><span class="function">    <span class="comment">// 每个 SocketChannel 对象创建时都是同一个对应的 java.net.Socket 对象对应的。	</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 调用 socket( )方法能返回它对应的 Socket 对象</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 该Socket上调用 getChannel( )方法则能返回最初的那个SocketChannel</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">abstract</span> Socket <span class="title">socket</span><span class="params">( )</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用 connect( )方法或在通道关联的 Socket 对象上调用 connect()来将该 socket通道连接。</span></span><br><span class="line">    <span class="comment">// 如果通道处于阻塞模式那么与在对应的Socket上调用connect()方法一样，在连接建立好或超时过期之前都将保持阻塞</span></span><br><span class="line">    <span class="comment">// 当 connect( )方法在非阻塞模式下被调用时 SocketChannel 提供并发连接：它发起对请求地址的连接并且立即返回值。</span></span><br><span class="line">	<span class="comment">// 如果返回值是 true，说明连接立即建立了（这可能是本地环回连接）；</span></span><br><span class="line">	<span class="comment">// 如果连接不能立即建立， connect( )方法会返回 false 且并发地继续连接建立过程。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">connect</span> <span class="params">(SocketAddress remote)</span></span></span><br><span class="line"><span class="function">    	<span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="comment">// 假如某个SocketChannel 上当前正由一个并发连接，isConnectPending( )方法就会返回 true值。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isConnectionPending</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="comment">// 一旦一个 socket通道被连接，它将保持连接状态直到被关闭。可以通过调用布尔型的 isConnected( )方法来测试某个SocketChannel 当前是否已连接。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">finishConnect</span><span class="params">( )</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">validOps</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>调用 <code>finishConnect( )</code>方法来完成连接过程，该方法任何时候都可以安全地进行调用。假如在一<br>个非阻塞模式的 <code>SocketChannel</code> 对象上调用 <code>finishConnect( )</code>方法，将可能出现下列情形之一：</p>
<ul>
<li><code>connect( )</code>方法尚未被调用。那么将产生 <code>NoConnectionPendingException</code> 异常。</li>
<li>连接建立过程正在进行，尚未完成。那么什么都不会发生， <code>finishConnect()</code>方法会立即返回</li>
</ul>
<p><code>false</code> 值。</p>
<ul>
<li>在非阻塞模式下调用 <code>connect( )</code>方法之后， <code>SocketChannel</code> 又被切换回了阻塞模式。那么如果</li>
</ul>
<p>有必要的话，调用线程会阻塞直到连接建立完成， <code>finishConnect( )</code>方法接着就会返回 true<br>值。</p>
<ul>
<li>在初次调用 connect( )或最后一次调用 <code>finishConnect( )</code>之后，连接建立过程已经完成。那么</li>
</ul>
<p><code>SocketChannel</code> 对象的内部状态将被更新到已连接状态， <code>finishConnect( )</code>方法会返回 true<br>值，然后 <code>SocketChannel</code> 对象就可以被用来传输数据了。</p>
<ul>
<li>连接已经建立。那么什么都不会发生， <code>finishConnect( )</code>方法会返回 true 值。</li>
</ul>
<blockquote>
<p>当通道处于中间的连接等待（connection-pending）状态时，您只可以调用 <code>finishConnect( )</code>、<code>isConnectPending( )</code>或 <code>isConnected( )</code>方法。一旦连接建立过程成功完成， <code>isConnected( )</code>将返回 true值 。</p>
</blockquote>
<!-- 建立并发连接DEMO   -->
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Demonstrate asynchronous connection of a SocketChannel.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Ron Hitchens (ron@ronsoft.com)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectAsync</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String [] argv)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String host = <span class="string">"localhost"</span>;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">80</span>;</span><br><span class="line">        <span class="keyword">if</span> (argv.length == <span class="number">2</span>) &#123;</span><br><span class="line">            host = argv [<span class="number">0</span>];</span><br><span class="line">            port = Integer.parseInt (argv [<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        InetSocketAddress addr = <span class="keyword">new</span> InetSocketAddress (host, port);</span><br><span class="line">        SocketChannel sc = SocketChannel.open( );</span><br><span class="line">        sc.configureBlocking (<span class="keyword">false</span>);</span><br><span class="line">        System.out.println (<span class="string">"initiating connection"</span>);</span><br><span class="line">        sc.connect (addr);</span><br><span class="line">        <span class="keyword">while</span> ( ! sc.finishConnect( )) &#123;</span><br><span class="line">            doSomethingUseful( );</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println (<span class="string">"connection established"</span>);</span><br><span class="line">        <span class="comment">// Do something with the connected socket</span></span><br><span class="line">        <span class="comment">// The SocketChannel is still nonblocking</span></span><br><span class="line">        sc.close( );</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomethingUseful</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println (<span class="string">"doing something useless"</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Socket 通道是<strong>线程安全</strong>的。并发访问时无需特别措施来保护发起访问的多个线程，不过任何时<br>候都只有一个读操作和一个写操作在进行中。请记住， <strong>sockets 是面向流的而非包导向的</strong>。它们可<br>以保证发送的字节会按照顺序到达但无法承诺维持字节分组。某个发送器可能给一个 socket 写入了<br>20 个字节而接收器调用 <code>read( )</code>方法时却只收到了其中的 3 个字节。剩下的 17 个字节还是传输中。由于这个原因，让多个不配合的线程共享某个流 socket 的同一侧绝非一个好的设计选择。 </p>
</blockquote>
<blockquote>
<p><code>connect( )</code>和 <code>finishConnect( )</code>方法是互相同步的，并且只要其中一个操作正在进行，任何读或写的方法调用都会阻塞，即使是在非阻塞模式下。 </p>
</blockquote>
<h3 id="4-4、DatagramChannel"><a href="#4-4、DatagramChannel" class="headerlink" title="4.4、DatagramChannel"></a>4.4、DatagramChannel</h3><blockquote>
<p>正如 <code>SocketChannel</code> 模拟连接导向的流协议（如 <strong>TCP/IP</strong>）， <code>DatagramChannel</code> 则模拟包导向的<br>无连接协议（如 <strong>UDP/IP</strong>）,对应<code>DatagramSocket</code>： </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DatagramChannel</span></span></span><br><span class="line"><span class="class">	<span class="keyword">extends</span> <span class="title">AbstractSelectableChannel</span></span></span><br><span class="line"><span class="class">	<span class="keyword">implements</span> <span class="title">ByteChannel</span>, <span class="title">ScatteringByteChannel</span>, <span class="title">GatheringByteChannel</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// This is a partial API listing</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DatagramChannel <span class="title">open</span><span class="params">( )</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">abstract</span> DatagramSocket <span class="title">socket</span><span class="params">( )</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//receive( )方法将下次将传入的数据报的数据净荷复制到预备好的 ByteBuffer 中并返回一个SocketAddress 对象以指出数据来源。</span></span><br><span class="line">    <span class="comment">// 如果通道处于阻塞模式， receive( )可能无限期地休眠直到有包到达。</span></span><br><span class="line">    <span class="comment">// 如果是非阻塞模式，当没有可接收的包时则会返回 null。</span></span><br><span class="line">    <span class="comment">// 如果包内的数据超出缓冲区能承受的范围，多出的数据都会被悄悄地丢弃。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SocketAddress <span class="title">receive</span> <span class="params">(ByteBuffer dst)</span></span></span><br><span class="line"><span class="function">    	<span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    	</span><br><span class="line">    <span class="comment">// 调用 send( )会发送给定 ByteBuffer 对象的内容到给定 SocketAddress 对象所描述的目的地址和端口，内容范围为从当前 position 开始到末尾处结束。</span></span><br><span class="line">    <span class="comment">// 如果 DatagramChannel 对象处于阻塞模式，调用线程可能会休眠直到数据报被加入传输队列。</span></span><br><span class="line">	<span class="comment">// 如果通道是非阻塞的，返回值要么是字节缓冲区的字节数，要么是“0”。发送数据报是一个全有或全无（all-or-nothing）的行为。如果传输队列没有足够空间来承载整个数据报，那么什么内容都不会被发送。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">send</span> <span class="params">(ByteBuffer src, SocketAddress target)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"> 	<span class="comment">// 将 DatagramChannel 置于已连接的状态可以使除了它所“连接”到的地址之外的任何其他源地址的数据报被忽略,不同于流 socket，数据报 socket 的无状态性质不需要同远程系统进行对话来建立连接状态。没有实际的连接，只有用来指定允许的远程地址的本地状态信息。</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">abstract</span> DatagramChannel <span class="title">connect</span> <span class="params">(SocketAddress remote)</span></span></span><br><span class="line"><span class="function">    	<span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> DatagramChannel <span class="title">disconnect</span><span class="params">( )</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当一个 DatagramChannel 处于已连接状态时，发送数据将不用提供目的地址而且接收时的源地址也是已知的。这意味着 DatagramChannel 已连接时可以使用常规的 read( )和 write( )方法，包括scatter/gather 形式的读写来组合或分拆包的数据：</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// read( )方法返回读取字节的数量，如果通道处于非阻塞模式的话这个返回值可能是“0”。write( )方法的返回值同 send( )方法一致：要么返回缓冲区中的字节数量，要么返回“0”（如果由于通道处于非阻塞模式而导致数据报不能被发送）。当通道不是已连接状态时调用 read( )或write( )方法，都将产生 NotYetConnectedException 异常。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span> <span class="params">(ByteBuffer dst)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">read</span> <span class="params">(ByteBuffer [] dsts)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">read</span> <span class="params">(ByteBuffer [] dsts, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">    	<span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">write</span> <span class="params">(ByteBuffer src)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">write</span><span class="params">(ByteBuffer[] srcs)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">write</span><span class="params">(ByteBuffer[] srcs, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">    	<span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>DatagramChannel</code> 对象既可以充当服务器（监听者）也可以充当客户端（发送者）。 </p>
</blockquote>
<blockquote>
<p><code>DatagramChannel</code> 是无连接的。每个数据报（datagram）都是一个自包含的实体，拥有它自己<br>的目的地址及不依赖其他数据报的数据净荷。与面向流的的 socket 不同， <code>DatagramChannel</code> 可以发送单独的数据报给不同的目的地址。同样， <code>DatagramChannel</code> 对象也可以接收来自任意地址的数据包。每个到达的数据报都含有关于它来自何处的信息（源地址）。 </p>
</blockquote>
<blockquote>
<p>请注意，数据报协议的不可靠性是固有的，它们不对数据传输做保证。 <code>send( )</code>方法返回的非零<br>值并不表示数据报到达了目的地，仅代表数据报被成功加到本地网络层的传输队列。此外，传输过<br>程中的协议可能将数据报分解成碎片。例如，以太网不能传输超过 1,500 个字节左右的包。如果您<br>的数据报比较大，那么就会存在被分解成碎片的风险，成倍地增加了传输过程中包丢失的几率。被<br>分解的数据报在目的地会被重新组合起来，接收者将看不到碎片。但是，如果有一个碎片不能按时<br>到达，那么整个数据报将被丢弃。 </p>
</blockquote>
<p>下面列出了一些选择数据报 socket 而非流 socket 的理由：</p>
<ul>
<li>您的程序可以承受数据丢失或无序的数据。</li>
<li>您希望“发射后不管”（fire and forget）而不需要知道您发送的包是否已接收。</li>
<li>数据吞吐量比可靠性更重要。</li>
<li>您需要同时发送数据给多个接受者（多播或者广播）。</li>
<li>包实现比流实现更适合手边的任务。</li>
</ul>
<p>如果以上特征中的一个或多个适用于你的程序，那么数据报设计就是合适的。 </p>
<h4 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h4><!--使用 DatagramChannel 的时间服务客户端  -->
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteOrder;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.DatagramChannel;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeClient</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_TIME_PORT = <span class="number">37</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DIFF_1900 = <span class="number">2208988800L</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> port = DEFAULT_TIME_PORT;</span><br><span class="line">    <span class="keyword">protected</span> List remoteHosts;</span><br><span class="line">    <span class="keyword">protected</span> DatagramChannel channel;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimeClient</span> <span class="params">(String [] argv)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (argv.length == <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> Exception (<span class="string">"Usage: [ -p port ] host ..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        parseArgs (argv);</span><br><span class="line">        <span class="keyword">this</span>.channel = DatagramChannel.open( );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> InetSocketAddress <span class="title">receivePacket</span> <span class="params">(DatagramChannel channel,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               ByteBuffer buffer)</span></span></span><br><span class="line"><span class="function">    										<span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        buffer.clear( );</span><br><span class="line">        <span class="comment">// Receive an unsigned 32-bit, big-endian value</span></span><br><span class="line">        <span class="keyword">return</span> ((InetSocketAddress) channel.receive (buffer));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Send time requests to all the supplied hosts</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sendRequests</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">    	<span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate (<span class="number">1</span>);</span><br><span class="line">        Iterator it = remoteHosts.iterator( );</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext( )) &#123;</span><br><span class="line">            InetSocketAddress sa = (InetSocketAddress) it.next( );</span><br><span class="line">            System.out.println (<span class="string">"Requesting time from "</span></span><br><span class="line">            + sa.getHostName() + <span class="string">":"</span> + sa.getPort( ));</span><br><span class="line">            <span class="comment">// Make it empty (see RFC868)</span></span><br><span class="line">            buffer.clear().flip( );</span><br><span class="line">            <span class="comment">// Fire and forget</span></span><br><span class="line">            channel.send (buffer, sa);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Receive any replies that arrive</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getReplies</span><span class="params">( )</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Allocate a buffer to hold a long value</span></span><br><span class="line">        ByteBuffer longBuffer = ByteBuffer.allocate (<span class="number">8</span>);</span><br><span class="line">        <span class="comment">// Assure big-endian (network) byte order</span></span><br><span class="line">        longBuffer.order (ByteOrder.BIG_ENDIAN);</span><br><span class="line">        <span class="comment">// Zero the whole buffer to be sure</span></span><br><span class="line">        longBuffer.putLong (<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// Position to first byte of the low-order 32 bits</span></span><br><span class="line">        longBuffer.position (<span class="number">4</span>);</span><br><span class="line">        <span class="comment">// Slice the buffer; gives view of the low-order 32 bits</span></span><br><span class="line">        ByteBuffer buffer = longBuffer.slice( );</span><br><span class="line">        <span class="keyword">int</span> expect = remoteHosts.size( );</span><br><span class="line">        <span class="keyword">int</span> replies = <span class="number">0</span>;</span><br><span class="line">        System.out.println (<span class="string">""</span>);</span><br><span class="line">        System.out.println (<span class="string">"Waiting for replies..."</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            InetSocketAddress sa;</span><br><span class="line">            sa = receivePacket (channel, buffer);</span><br><span class="line">            buffer.flip( );</span><br><span class="line">            replies++;</span><br><span class="line">            printTime (longBuffer.getLong (<span class="number">0</span>), sa);</span><br><span class="line">            <span class="keyword">if</span> (replies == expect) &#123;</span><br><span class="line">                System.out.println (<span class="string">"All packets answered"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Some replies haven't shown up yet</span></span><br><span class="line">            System.out.println (<span class="string">"Received "</span> + replies</span><br><span class="line">            + <span class="string">" of "</span> + expect + <span class="string">" replies"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Print info about a received time reply</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">printTime</span> <span class="params">(<span class="keyword">long</span> remote1900, InetSocketAddress sa)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// local time as seconds since Jan 1, 1970</span></span><br><span class="line">        <span class="keyword">long</span> local = System.currentTimeMillis( ) / <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">// remote time as seconds since Jan 1, 1970</span></span><br><span class="line">        <span class="keyword">long</span> remote = remote1900 - DIFF_1900;</span><br><span class="line">        Date remoteDate = <span class="keyword">new</span> Date (remote * <span class="number">1000</span>);</span><br><span class="line">        Date localDate = <span class="keyword">new</span> Date (local * <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">long</span> skew = remote - local;</span><br><span class="line">        System.out.println (<span class="string">"Reply from "</span></span><br><span class="line">        + sa.getHostName() + <span class="string">":"</span> + sa.getPort( ));</span><br><span class="line">        System.out.println (<span class="string">" there: "</span> + remoteDate);</span><br><span class="line">        System.out.println (<span class="string">" here: "</span> + localDate);</span><br><span class="line">        System.out.print (<span class="string">" skew: "</span>);</span><br><span class="line">        <span class="keyword">if</span> (skew == <span class="number">0</span>) &#123;</span><br><span class="line">        	System.out.println (<span class="string">"none"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (skew &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        	System.out.println (skew + <span class="string">" seconds ahead"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       		System.out.println ((-skew) + <span class="string">" seconds behind"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseArgs</span> <span class="params">(String [] argv)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        remoteHosts = <span class="keyword">new</span> LinkedList( );</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; argv.length; i++) &#123;</span><br><span class="line">            String arg = argv [i];</span><br><span class="line">            <span class="comment">// Send client requests to the given port</span></span><br><span class="line">            <span class="keyword">if</span> (arg.equals (<span class="string">"-p"</span>)) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">this</span>.port = Integer.parseInt (argv [i]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Create an address object for the hostname</span></span><br><span class="line">        InetSocketAddress sa = <span class="keyword">new</span> InetSocketAddress (arg, port);</span><br><span class="line">        <span class="comment">// Validate that it has an address</span></span><br><span class="line">        <span class="keyword">if</span> (sa.getAddress( ) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println (<span class="string">"Cannot resolve address: "</span></span><br><span class="line">            + arg);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        	remoteHosts.add (sa);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// --------------------------------------------------------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String [] argv)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    TimeClient client = <span class="keyword">new</span> TimeClient (argv);</span><br><span class="line">    client.sendRequests( );</span><br><span class="line">    client.getReplies( );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!--DatagramChannel 时间服务器  -->
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteOrder;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.DatagramChannel;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeServer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_TIME_PORT = <span class="number">37</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DIFF_1900 = <span class="number">2208988800L</span>;</span><br><span class="line">    <span class="keyword">protected</span> DatagramChannel channel;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimeServer</span> <span class="params">(<span class="keyword">int</span> port)</span></span></span><br><span class="line"><span class="function">    	<span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.channel = DatagramChannel.open( );</span><br><span class="line">        <span class="keyword">this</span>.channel.socket( ).bind (<span class="keyword">new</span> InetSocketAddress (port));</span><br><span class="line">        System.out.println (<span class="string">"Listening on port "</span> + port</span><br><span class="line">        + <span class="string">" for time requests"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">( )</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Allocate a buffer to hold a long value</span></span><br><span class="line">        ByteBuffer longBuffer = ByteBuffer.allocate (<span class="number">8</span>);</span><br><span class="line">        <span class="comment">// Assure big-endian (network) byte order</span></span><br><span class="line">        longBuffer.order (ByteOrder.BIG_ENDIAN);</span><br><span class="line">        <span class="comment">// Zero the whole buffer to be sure</span></span><br><span class="line">        longBuffer.putLong (<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// Position to first byte of the low-order 32 bits</span></span><br><span class="line">        longBuffer.position (<span class="number">4</span>);</span><br><span class="line">        <span class="comment">// Slice the buffer; gives view of the low-order 32 bits</span></span><br><span class="line">        ByteBuffer buffer = longBuffer.slice( );</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            buffer.clear( );</span><br><span class="line">            SocketAddress sa = <span class="keyword">this</span>.channel.receive (buffer);</span><br><span class="line">            <span class="keyword">if</span> (sa == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// defensive programming</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Ignore content of received datagram per RFC 868</span></span><br><span class="line">        System.out.println (<span class="string">"Time request from "</span> + sa);</span><br><span class="line">        buffer.clear( ); <span class="comment">// sets pos/limit correctly</span></span><br><span class="line">        <span class="comment">// Set 64-bit value; slice buffer sees low 32 bits</span></span><br><span class="line">        longBuffer.putLong (<span class="number">0</span>, (System.currentTimeMillis( ) / <span class="number">1000</span>) + DIFF_1900);</span><br><span class="line">        <span class="keyword">this</span>.channel.send (buffer, sa);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// --------------------------------------------------------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String [] argv)</span></span></span><br><span class="line"><span class="function">    	<span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> port = DEFAULT_TIME_PORT;</span><br><span class="line">        <span class="keyword">if</span> (argv.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        port = Integer.parseInt (argv [<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeServer server = <span class="keyword">new</span> TimeServer (port);</span><br><span class="line">            server.listen( );</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            System.out.println (<span class="string">"Can't bind to port "</span> + port</span><br><span class="line">            + <span class="string">", try a different one"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="5、管道"><a href="#5、管道" class="headerlink" title="5、管道"></a>5、管道</h1><blockquote>
<p><code>java.nio.channels</code> 包中含有一个名为 <code>Pipe</code>（管道）的类。广义上讲，管道就是一个用来<br>在两个实体之间单向传输数据的导管。管道的概念对于 Unix（和类 Unix）操作系统的用户来说早<br>就很熟悉了。 Unix 系统中，管道被用来连接一个进程的输出和另一个进程的输入。 <code>Pipe</code> 类实现一<br>个管道范例，不过它所创建的管道是进程内（在 Java 虚拟机进程内部）而非进程间使用的。 </p>
</blockquote>
<p><code>Pipe</code> 类创建一对提供环回机制的 <code>Channel</code> 对象。这两个通道的远端是连接起来的，以便任何写在 <code>SinkChannel</code> 对象上的数据都能出现在 <code>SourceChannel</code> 对象上。 </p>
<p><img src="java-nio-channel\1532358532450.png" alt="53235853245"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.nio.channels;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Pipe</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建Pipe</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pipe <span class="title">open</span><span class="params">( )</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    <span class="comment">// 返回SourceChannel</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">abstract</span> SourceChannel <span class="title">source</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="comment">// 返回SinkChannel</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SinkChannel <span class="title">sink</span><span class="params">( )</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SourceChannel</span></span></span><br><span class="line"><span class="class">    	<span class="keyword">extends</span> <span class="title">AbstractSelectableChannel</span></span></span><br><span class="line"><span class="class">    	<span class="keyword">implements</span> <span class="title">ReadableByteChannel</span>, <span class="title">ScatteringByteChannel</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">static</span> <span class="title">abstract</span> <span class="title">class</span> <span class="title">SinkChannel</span></span></span><br><span class="line"><span class="class">    	<span class="keyword">extends</span> <span class="title">AbstractSelectableChannel</span></span></span><br><span class="line"><span class="class">    	<span class="keyword">implements</span> <span class="title">WritableByteChannel</span>, <span class="title">GatheringByteChannel</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>管道可以被用来仅在同一个 Java 虚拟机内部传输数据。虽然有更加有效率的方式来在线程之间传输数据，但是使用管道的好处在于封装性。生产者线程和用户线程都能被写道通用的 Channel API 中。根据给定的通道类型，相同的代码可以被用来写数据到一个文件、 socket 或管道。选择器可以被用来检查管道上的数据可用性，如同在 socket 通道上使用那样地简单。这样就可以允许单个用户线程使用一个 Selector 来从多个通道有效地收集数据，并可任意结合网络连接或本地工作线程使用。因此，这些对于可伸缩性、冗余度以及可复用性来说无疑都是意义重大的。 </p>
</blockquote>
<blockquote>
<p>Pipes 的另一个有用之处是可以用来辅助测试。一个单元测试框架可以将某个待测试的类连接到管道的“写”端并检查管道的“读”端出来的数据。它也可以将被测试的类置于通道的“读”端并将受控的测试数据写进其中。两种场景对于回归测试都是很有帮助的 </p>
</blockquote>
<hr>
<h1 id="6、通道工具类"><a href="#6、通道工具类" class="headerlink" title="6、通道工具类"></a>6、通道工具类</h1><blockquote>
<p>NIO 通道提供了一个全新的类似流的 I/O 隐喻，但是我们所熟悉的字节流以及字符读写器仍然存在并被广泛使用。通道可能最终会改进加入到 java.io 类中（这是一个实现细节），但是java.io 流所代表的 API 和读写器却不会很快消失（它们也不应该消失）。 </p>
</blockquote>
<p>一个工具类（<code>java.nio.channels.Channels</code> 的一个稍微重复的名称）定义了几种静态的工厂方法以使通道可以更加容易地同流和读写器互联。下图对这些方法做了一个汇总 </p>
<p><img src="java-nio-channel\1532359375876.png" alt="53235937587"></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java/" rel="tag"># java</a>
          
            <a href="/tags/nio/" rel="tag"># nio</a>
          
            <a href="/tags/通道channel/" rel="tag"># 通道channel</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/22/first-test/" rel="next" title="前端图标字体 .webfont">
                <i class="fa fa-chevron-left"></i> 前端图标字体 .webfont
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/07/17/java-concurrent-lock/" rel="prev" title="Java并发编程实战学习笔记--锁Lock">
                Java并发编程实战学习笔记--锁Lock <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Inhaltsverzeichnis
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Übersicht
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="kx" />
          <p class="site-author-name" itemprop="name">kx</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">Artikel</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">Kategorien</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">Tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1、通道基础"><span class="nav-number">1.</span> <span class="nav-text">1、通道基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1、打开通道"><span class="nav-number">1.0.1.</span> <span class="nav-text">1.1、打开通道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2、使用通道"><span class="nav-number">1.0.2.</span> <span class="nav-text">1.2、使用通道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3、关闭通道"><span class="nav-number">1.0.3.</span> <span class="nav-text">1.3、关闭通道</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2、Scatter-Gather"><span class="nav-number">2.</span> <span class="nav-text">2、Scatter/Gather</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3、文件通道"><span class="nav-number">3.</span> <span class="nav-text">3、文件通道</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4、Socket通道"><span class="nav-number">4.</span> <span class="nav-text">4、Socket通道</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1、非阻塞模式"><span class="nav-number">4.0.1.</span> <span class="nav-text">4.1、非阻塞模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2、ServerSocketChannel"><span class="nav-number">4.0.2.</span> <span class="nav-text">4.2、ServerSocketChannel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3、SocketChannel"><span class="nav-number">4.0.3.</span> <span class="nav-text">4.3、SocketChannel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4、DatagramChannel"><span class="nav-number">4.0.4.</span> <span class="nav-text">4.4、DatagramChannel</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DEMO"><span class="nav-number">4.0.4.1.</span> <span class="nav-text">DEMO</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5、管道"><span class="nav-number">5.</span> <span class="nav-text">5、管道</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6、通道工具类"><span class="nav-number">6.</span> <span class="nav-text">6、通道工具类</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">kx</span>
</div>


<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
